//Dependicies #include "llvm/IR/LLVMContext.h" #include "llvm/IR/IRBuilder.h" 
//Make sure you include the following opjects.
static LLVMContext IRContext;
static IRBuilder<> Builder(IRContext);
static std::unique_ptr<Module> CurModule;

addexp ->
if (!float)
{
return Builder.CreateAdd(register1,register2,"addTmp");
if (float)
{
return Builder.CreataFAdd(register1,register2, "fAddTmp");
}

subexp ->
if (!float)
{
return Builder.CreateSub(register1,register2,"subTmp");
}
if (float)
{
return Builder.CreateFSub(register1,register2,"fSubTmp");
}

mulexp ->
if (!float)
{
return Builder.CreateMul(register1,register2,"mulTmp");
}
if (float)
{
return Builder.CreateFMul(register1,register2,"fMulTmp");
}

divexp ->
if (!float)
{
return Builder.CreateSDiv(register1,register2,"sDivTmp");
}
if (float)
{
return Builder.CreateFDiv(register1,register2,"fDivTmp");
} 

++exp ->
ConstantData* num;
if (int)
{
num = ConstantInt::get(IRContext,APInt(4,1));
}
if (float)
{
num = ConstantFP::get(IRContext,APFloat(1.0f));
}
 return Builder.CreateAdd(register1,num,"inc");
--exp ->
ConstantData* num;
if (int)
{
num = ConstantInt::get(IRContext,APInt(4,1));
}
if (float)
{
num = ConstantFP::get(IRContext,APFloat(1.0f));
}return Builder.CreateSub(register1,num,"dec");

<<exp -> return Builder.CreateShl(register1,register2,"shl");
>>exp -> return Builder.CreateLShr(register1,register2,"LShr");

&exp -> return Builder.CreateAnd(register1,register2,"and");
^exp -> return Builder.CreateXor(register1,register2,"xor");
|exp -> return Builder.CreateOr(register1,register2,"or");

^^exp ->

<exp ->
 if (signed)
{
return Builder.CreateICmpSLT(register1,register2,"icmp_slt");
}
if (unsigned)
{
return Builder.CreateICmpULT(register1,register2,"icmp_ult");
}
>exp -> 
 if (signed)
{
return Builder.CreateICmpSGT(register1,register2,"icmp_sgt");
}
if (unsigned)
{
return Builder.CreateICmpUGT(register1,register2,"icmp_ugt");
}
<=exp -> 
 if (signed)
{
return Builder.CreateICmpSLE(register1,register2,"icmp_sle");
}
if (unsigned)
{
return Builder.CreateICmpULE(register1,register2,"icmp_ule");
}
>=exp -> 
 if (signed)
{
return Builder.CreateICmpSGE(register1,register2,"icmp_sge");
}
if (unsigned)
{
return CreateICmpUGE(register1,register2,"icmp_uge");
}
==exp -> return Builder.CreateICmpEQ(register1,register2,"icmp_eq");
!=exp -> return Builder.CreateICmpNE(register1,register2,"icmp_ne");

whileloop ->
BasicBlock *loop = BasicBlock::Create(IRContext,"loop");
BasicBlock *endLoop = BasicBlock::Create(IRContext,"endLoop");
BasicBlock *condEval = BasicBlock::Create(IRContext,"condEval",function);
Builder.SetInsertPoint(condEval);
generateConditionalCode();
Builder.CreateCondBr(Condition_Statement_Register,loop,endLoop);
Builder.SetInsertPoint(loop);
GenerateLoopCode();
Builder.CreateBr(condEval);
Builder.SetInsertPoint(endLoop);
GenerateRestOfFunctionCode();

ifStat ->
Function *ifBranchFunc = Builder.GetInsertBlock() -> getParent();
 //The function is the current function being built. Change name to function being built.
BasicBlock *ifBB = BasicBlock::Create(IRContext,"ifStats",ifBranchFunc);
BasicBlock *ElseBB = BasicBlock::Create(IRContext,"elseStats");
BasicBlock *MergeBB = BasicBlock::Create(IRContext,"merge"); 
Builder.CreateCondBr(Condtion_Statement_Register,ifBB,ElseBB);
Builder.SetInsertPoint(ifBranchFunc);
generateIfBranch(); //Generates the code in the if branch.
Builder.CreatBr(MergeBB);
MergeBB = Builder.GetInsertBlock(); //Updates branch in case of recursive function.
ifBranchFunc->getBasicBlockList().push_back(ElseBB); //Adds block to function.
Builder.SetInsertPoint(ElseBB);
generateElseBranc(); //Generates the code for the else branch.
Builder.CreateBr(MergeBB);
MergeBB = Builder.GetInsertBlock();
ifBranchFunc->Builder.GetBasicBlockList().push_back(MergeBB);
Builder.SetInsertPoint(MergeBB);




varDefine ->




varCall ->


asgStat ->


FuncDecl ->
//generateReturnType is a fill in function to define how we'll decide on what the return type will be.
Type *retType = generateReturnType();
FunctionType* funcType = FunctionType::get(retType,ArrayRef //The ref can be generated from a vector of types, refer to https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.html, false);
Function* func = Function::Create(funcType,Function::ExternalLinkage,functionNameString,CurModule.get());
BasicBlock *funcBlock = BasicBlock::Create(IRContext,functionNameString + "block",func);
Builder.SetInsertPoint(funcBlock);
FunctionInternalsCodeGen();
Builder.CreateRet(RetVal);
verifyFunction(*func);
return func;


